#include <iostream>
#ifdef HAVE_LIMITS
#include <limits>
#else
#include "hoops/hoops_limits.h"
#endif
#include "hoops/hoops.h"
#include "hoops_prim.cxx"

static int sStatus = hoops::P_OK;
static const int ERROR_UNDETECTED =  + 1;

int SetGlobalStatus (int status) {
  using namespace hoops;
  if (P_OK == sStatus) {
    if (P_OK == status) sStatus = ERROR_UNDETECTED;
    else sStatus = status;
  }
  return sStatus;
}

int main() {
  using namespace hoops;
#ifdef HAVE_LIMITS
  using std::numeric_limits;
#endif

  const char *code[1024];

  for (int ii = 0; ii < 1024; ++ii) code[ii] = "";
  code[P_OK] = "P_OK";
  code[P_ILLEGAL] = "P_ILLEGAL";
  code[P_OVERFLOW] = "P_OVERFLOW";
  code[P_UNDERFLOW] = "P_UNDERFLOW";
  code[P_BADSIZE] = "P_BADSIZE";
  code[P_PRECISION] = "P_PRECISION";
  code[P_SIGNEDNESS] = "P_SIGNEDNESS";
  code[P_STR_OVERFLOW] = "P_STR_OVERFLOW";
  code[P_STR_INVALID] = "P_STR_INVALID";
  code[P_STR_NULL] = "P_STR_NULL";
  code[P_UNEXPECTED] = "P_UNEXPECTED";
  code[ERROR_UNDETECTED] = "ERROR_UNDETECTED";

  std::cout.precision(32);
  std::cerr.precision(32);

  // Declare one variable for each primitive type's maximum.
  const bool max_bool = Lim<bool>::max;
  const char max_char = Lim<char>::max;
  const signed char max_signed_char = Lim<signed char>::max;
  const short max_short = Lim<short>::max;
  const int max_int = Lim<int>::max;
  const long max_long = Lim<long>::max;
  const unsigned char max_unsigned_char = Lim<unsigned char>::max;
  const unsigned short max_unsigned_short = Lim<unsigned short>::max;
  const unsigned int max_unsigned_int = Lim<unsigned int>::max;
  const unsigned long max_unsigned_long = Lim<unsigned long>::max;
  const float max_float = Lim<float>::max;
  const double max_double = Lim<double>::max;
  const long double max_long_double = Lim<long double>::max;

  // Declare one variable for each primitive type's minimum.
  const bool min_bool = Lim<bool>::min;
  const char min_char = Lim<char>::min;
  const signed char min_signed_char = Lim<signed char>::min;
  const short min_short = Lim<short>::min;
  const int min_int = Lim<int>::min;
  const long min_long = Lim<long>::min;
  const unsigned char min_unsigned_char = Lim<unsigned char>::min;
  const unsigned short min_unsigned_short = Lim<unsigned short>::min;
  const unsigned int min_unsigned_int = Lim<unsigned int>::min;
  const unsigned long min_unsigned_long = Lim<unsigned long>::min;
  const float min_float = Lim<float>::min;
  const double min_double = Lim<double>::min;
  const long double min_long_double = Lim<long double>::min;

  // Declare one variable for each primitive type's scratch value.
  bool tmp_bool;
  char tmp_char;
  signed char tmp_signed_char;
  short tmp_short;
  int tmp_int;
  long tmp_long;
  unsigned char tmp_unsigned_char;
  unsigned short tmp_unsigned_short;
  unsigned int tmp_unsigned_int;
  unsigned long tmp_unsigned_long;
  float tmp_float;
  double tmp_double;
  long double tmp_long_double;

  // Status variable, used to test success of each conversion.
  int status = P_OK;

  // Declare one variable of each Prim type, and initialize them to maximum.

  // Catch-all try block:
  try {
    Prim<bool> hd_prim_bool = Lim<bool>::max;
    Prim<char> hd_prim_char = Lim<char>::max;
    Prim<signed char> hd_prim_signed_char = Lim<signed char>::max;
    Prim<short> hd_prim_short = Lim<short>::max;
    Prim<int> hd_prim_int = Lim<int>::max;
    Prim<long> hd_prim_long = Lim<long>::max;
    Prim<unsigned char> hd_prim_unsigned_char = Lim<unsigned char>::max;
    Prim<unsigned short> hd_prim_unsigned_short = Lim<unsigned short>::max;
    Prim<unsigned int> hd_prim_unsigned_int = Lim<unsigned int>::max;
    Prim<unsigned long> hd_prim_unsigned_long = Lim<unsigned long>::max;
    Prim<float> hd_prim_float = Lim<float>::max;
    Prim<double> hd_prim_double = Lim<double>::max;
    Prim<long double> hd_prim_long_double = Lim<long double>::max;

    // Test whether construction from maximum value worked
    if (Lim<bool>::max != hd_prim_bool.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_bool has value " << hd_prim_bool << ", not " << Lim<bool>::max << std::endl;
     }
    if (Lim<char>::max != hd_prim_char.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_char has value " << hd_prim_char << ", not " << Lim<char>::max << std::endl;
     }
    if (Lim<signed char>::max != hd_prim_signed_char.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_signed_char has value " << hd_prim_signed_char << ", not " << Lim<signed char>::max << std::endl;
     }
    if (Lim<short>::max != hd_prim_short.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_short has value " << hd_prim_short << ", not " << Lim<short>::max << std::endl;
     }
    if (Lim<int>::max != hd_prim_int.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_int has value " << hd_prim_int << ", not " << Lim<int>::max << std::endl;
     }
    if (Lim<long>::max != hd_prim_long.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_long has value " << hd_prim_long << ", not " << Lim<long>::max << std::endl;
     }
    if (Lim<unsigned char>::max != hd_prim_unsigned_char.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_char has value " << hd_prim_unsigned_char << ", not " << Lim<unsigned char>::max << std::endl;
     }
    if (Lim<unsigned short>::max != hd_prim_unsigned_short.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_short has value " << hd_prim_unsigned_short << ", not " << Lim<unsigned short>::max << std::endl;
     }
    if (Lim<unsigned int>::max != hd_prim_unsigned_int.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_int has value " << hd_prim_unsigned_int << ", not " << Lim<unsigned int>::max << std::endl;
     }
    if (Lim<unsigned long>::max != hd_prim_unsigned_long.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_unsigned_long has value " << hd_prim_unsigned_long << ", not " << Lim<unsigned long>::max << std::endl;
     }
    if (Lim<float>::max != hd_prim_float.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_float has value " << hd_prim_float << ", not " << Lim<float>::max << std::endl;
     }
    if (Lim<double>::max != hd_prim_double.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_double has value " << hd_prim_double << ", not " << Lim<double>::max << std::endl;
     }
    if (Lim<long double>::max != hd_prim_long_double.Data()) {
      SetGlobalStatus(P_UNEXPECTED);
      std::cerr << "ERROR: Immediately after creation, hd_prim_long_double has value " << hd_prim_long_double << ", not " << Lim<long double>::max << std::endl;
     }

    // At this point, each Prim variable contains the maximum value for
    // its underlying type. Try converting each one to each type of
    // C++ primitive variable. This should cause a maximum number of
    // overflows and no underflows.
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_float) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_float) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_float) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_bool.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_bool.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_signed_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_signed_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_unsigned_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_unsigned_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_float) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_float.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 0; // Not maximum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from maximum, hd_prim_long_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_OVERFLOW:
        if (max_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from maximum, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }

    // Try to set each Prim variable to the minimum value for its underlying type.
    hd_prim_bool = Lim<bool>::min;
    hd_prim_char = Lim<char>::min;
    hd_prim_signed_char = Lim<signed char>::min;
    hd_prim_short = Lim<short>::min;
    hd_prim_int = Lim<int>::min;
    hd_prim_long = Lim<long>::min;
    hd_prim_unsigned_char = Lim<unsigned char>::min;
    hd_prim_unsigned_short = Lim<unsigned short>::min;
    hd_prim_unsigned_int = Lim<unsigned int>::min;
    hd_prim_unsigned_long = Lim<unsigned long>::min;
    hd_prim_float = Lim<float>::min;
    hd_prim_double = Lim<double>::min;
    hd_prim_long_double = Lim<long double>::min;


    // At this point, each Prim variable contains the minimum value for
    // its underlying type. Try converting each one to each type of
    // C++ primitive variable. This should cause a maximum number of
    // underflows and no overflows.
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_float) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_float) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_float) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_bool.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_bool.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_signed_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_signed_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_unsigned_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_unsigned_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_float) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_float.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_bool = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_bool != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_char != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_signed_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_signed_char != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_short != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_int != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_char = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_char != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_short = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_short != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_int = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_int != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_unsigned_long = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_unsigned_long != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_float = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_float != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_double != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }
    tmp_long_double = 1; // Not minimum value for any type.
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            std::cerr << "WARNING: While converting from minimum, hd_prim_long_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
      case P_UNDERFLOW:
        if (min_long_double != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from minimum, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double << std::endl <<
              "while returning status " << code[status] << std::endl;
        }
        break;
    }

    // Try to assign each Prim variable a value which can be converted
    // to all types without throwing an exception, namely, 1.
    hd_prim_bool = (bool) Lim<bool>::max;
    hd_prim_char = (char) Lim<bool>::max;
    hd_prim_signed_char = (signed char) Lim<bool>::max;
    hd_prim_short = (short) Lim<bool>::max;
    hd_prim_int = (int) Lim<bool>::max;
    hd_prim_long = (long) Lim<bool>::max;
    hd_prim_unsigned_char = (unsigned char) Lim<bool>::max;
    hd_prim_unsigned_short = (unsigned short) Lim<bool>::max;
    hd_prim_unsigned_int = (unsigned int) Lim<bool>::max;
    hd_prim_unsigned_long = (unsigned long) Lim<bool>::max;
    hd_prim_float = (float) Lim<bool>::max;
    hd_prim_double = (double) Lim<bool>::max;
    hd_prim_long_double = (long double) Lim<bool>::max;


    // At this point, each Prim variable contains the value 1
    // Try converting each one to each type of C++ primitive variable.
    // This should lead to a minimum of exceptions.
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_bool) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_float) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_float) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_bool.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_bool.Data() != (bool) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_bool.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_bool.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_bool.Data();
          long double maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_bool.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_bool.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_char.Data() != (char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_char.Data();
          long double maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_signed_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_signed_char.Data() != (signed char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_signed_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_signed_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_signed_char.Data();
          long double maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_signed_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_signed_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_short.Data() != (short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_short.Data();
          long double maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_int.Data() != (int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_int.Data();
          long double maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long.Data() != (long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long.Data();
          long double maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_char.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_char.Data() != (unsigned char) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_char.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_char.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_char.Data();
          long double maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_char.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_char.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_short.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_short.Data() != (unsigned short) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_short.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_short.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_short.Data();
          long double maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_short.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_short.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_int.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_int.Data() != (unsigned int) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_int.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_int.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_int.Data();
          long double maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_int.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_int.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_bool) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_float) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_float) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_unsigned_long.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_unsigned_long.Data() != (unsigned long) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_unsigned_long.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_unsigned_long.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_unsigned_long.Data();
          long double maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_unsigned_long.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_unsigned_long.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_float) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_float.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_float.Data();
          long double maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_float.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_float.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_double.Data();
          long double maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_bool;
          if (0. > difference)
            difference = (long double) tmp_bool - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<bool>::round_error())
            maxdiff = numeric_limits<bool>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_bool) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_bool << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_char;
          if (0. > difference)
            difference = (long double) tmp_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<char>::round_error())
            maxdiff = numeric_limits<char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_signed_char;
          if (0. > difference)
            difference = (long double) tmp_signed_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<signed char>::round_error())
            maxdiff = numeric_limits<signed char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_signed_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_signed_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_short;
          if (0. > difference)
            difference = (long double) tmp_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<short>::round_error())
            maxdiff = numeric_limits<short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_int;
          if (0. > difference)
            difference = (long double) tmp_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<int>::round_error())
            maxdiff = numeric_limits<int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long;
          if (0. > difference)
            difference = (long double) tmp_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long>::round_error())
            maxdiff = numeric_limits<long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_char;
          if (0. > difference)
            difference = (long double) tmp_unsigned_char - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned char>::round_error())
            maxdiff = numeric_limits<unsigned char>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_char) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_char << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_short;
          if (0. > difference)
            difference = (long double) tmp_unsigned_short - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned short>::round_error())
            maxdiff = numeric_limits<unsigned short>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_short) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_short << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_int;
          if (0. > difference)
            difference = (long double) tmp_unsigned_int - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned int>::round_error())
            maxdiff = numeric_limits<unsigned int>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_int) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_int << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_unsigned_long;
          if (0. > difference)
            difference = (long double) tmp_unsigned_long - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<unsigned long>::round_error())
            maxdiff = numeric_limits<unsigned long>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_unsigned_long) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_unsigned_long << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_float;
          if (0. > difference)
            difference = (long double) tmp_float - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<float>::round_error())
            maxdiff = numeric_limits<float>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_float) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_float << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_double;
          if (0. > difference)
            difference = (long double) tmp_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<double>::round_error())
            maxdiff = numeric_limits<double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_OVERFLOW:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_PRECISION:
        {
          long double difference = (long double) hd_prim_long_double.Data() - tmp_long_double;
          if (0. > difference)
            difference = (long double) tmp_long_double - hd_prim_long_double.Data();
          long double maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < numeric_limits<long double>::round_error())
            maxdiff = numeric_limits<long double>::round_error();
          if (maxdiff < difference) {
            SetGlobalStatus(status);
            std::cerr << "ERROR: While converting from 1, hd_prim_long_double.To(tmp_long_double) rounded incorrectly from " <<
                hd_prim_long_double.Data() << " to " << tmp_long_double << " diff " << difference << " maxdiff " << maxdiff << std::endl;
          }
        }
        break;
    }

    // Assign Prim floating types a non-integral value, and
    // confirm that it converts correctly to all types.

    hd_prim_float = 1 + Lim<float>::epsilon;
    hd_prim_double = 1 + Lim<float>::epsilon;
//    hd_prim_long_double = 1 + Lim<float>::epsilon;
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_bool) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_float) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_float.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_float.Data() != (float) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_float.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_float.Data() << " to " << tmp_long_double;
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_double.Data() != (double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_double.Data() << " to " << tmp_long_double;
        }
        break;
    }
    tmp_bool = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_bool);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_bool) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<bool>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_bool) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_bool) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_bool) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_bool;
        }
        break;
    }
    tmp_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_char;
        }
        break;
    }
    tmp_signed_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_signed_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_signed_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<signed char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_signed_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_signed_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_signed_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_signed_char;
        }
        break;
    }
    tmp_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_short;
        }
        break;
    }
    tmp_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_int;
        }
        break;
    }
    tmp_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long;
        }
        break;
    }
    tmp_unsigned_char = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_char);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_char) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned char>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_char) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_char) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_char) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_char;
        }
        break;
    }
    tmp_unsigned_short = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_short);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_short) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned short>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_short) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_short) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_short) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_short;
        }
        break;
    }
    tmp_unsigned_int = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_int);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_int) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned int>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_int) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_int) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_int) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_int;
        }
        break;
    }
    tmp_unsigned_long = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_unsigned_long);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_long) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<unsigned long>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_long) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_unsigned_long) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_unsigned_long) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_unsigned_long;
        }
        break;
    }
    tmp_float = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_float);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_float) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<float>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_float) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_float) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_float) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_float;
        }
        break;
    }
    tmp_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_double;
        }
        break;
    }
    tmp_long_double = 0; // 0 is not 1
    status = P_OK;
    try {
      hd_prim_long_double.To(tmp_long_double);
    } catch (const Hexception &x) {
      status = x.Code();
    }

    switch (status) {
      case P_ILLEGAL:
      case P_UNDERFLOW:
      case P_STR_OVERFLOW:
      case P_STR_INVALID:
      case P_STR_NULL:
      case P_UNEXPECTED:
        SetGlobalStatus(status);
        std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long_double) threw a " <<
          code[status] << " exception." << std::endl;
        break;
      case P_OK:
      case P_BADSIZE:
      case P_SIGNEDNESS:
        if (hd_prim_long_double.Data() != (long double) tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double;
          if (P_OK != status)
            std::cerr << std::endl << "and threw a " <<
                code[status] << " exception";
          std::cerr << "." << std::endl;
        }
        break;
      case P_OVERFLOW:
        if (P_BOOL != Lim<long double>::code) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long_double) threw a " <<
            code[status] << " exception." << std::endl;
          break;
        }
      case P_PRECISION:
        if (1 != tmp_long_double) {
          SetGlobalStatus(status);
          std::cerr << "ERROR: While converting from 1 + epsilon, hd_prim_long_double.To(tmp_long_double) converted incorrectly from " <<
              hd_prim_long_double.Data() << " to " << tmp_long_double;
        }
        break;
    }
    const char *tmp_c_char_p = "A non-numeric string";
    Prim<char *> hd_prim_char_p = tmp_c_char_p;
    if (strcmp(hd_prim_char_p.Data(), tmp_c_char_p))
      std::cerr << "ERROR: After initialization from const char *, hd_prim_char is " << hd_prim_char.Data() << ", not " << tmp_c_char_p << std::endl;
    try {
      hd_prim_char_p.To(tmp_bool);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_bool) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to bool, hd_prim_char_p.To(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_char);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to char, hd_prim_char_p.To(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_signed_char);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_signed_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to signed_char, hd_prim_char_p.To(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_short);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_short) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to short, hd_prim_char_p.To(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_int);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_int) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to int, hd_prim_char_p.To(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_long);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_long) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to long, hd_prim_char_p.To(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_unsigned_char);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_unsigned_char) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to unsigned_char, hd_prim_char_p.To(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_unsigned_short);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_unsigned_short) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to unsigned_short, hd_prim_char_p.To(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_unsigned_int);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_unsigned_int) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to unsigned_int, hd_prim_char_p.To(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_unsigned_long);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_unsigned_long) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to unsigned_long, hd_prim_char_p.To(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_float);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_float) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to float, hd_prim_char_p.To(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_double);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_double) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to double, hd_prim_char_p.To(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    try {
      hd_prim_char_p.To(tmp_long_double);
      std::cerr << "ERROR: While converting from a non-numeric string, hd_prim_char_p.To(tmp_long_double) didn't throw an exception" << std::endl;
    } catch (const Hexception &x) {
      if (P_STR_INVALID != x.Code())
        std::cerr << "ERROR: While converting to long_double, hd_prim_char_p.To(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_bool = 1;
    try {
      hd_prim_char_p.From(tmp_bool);
      if (strcmp(hd_prim_char_p.Data(), "true"))
        std::cerr << "ERROR: While converting from bool, hd_prim_char_p.From(tmp_bool) converted incorrectly from " << tmp_bool << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from bool, hd_prim_char_p.From(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_char = 1;
    try {
      hd_prim_char_p.From(tmp_char);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from char, hd_prim_char_p.From(tmp_char) converted incorrectly from " << tmp_char << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from char, hd_prim_char_p.From(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_signed_char = 1;
    try {
      hd_prim_char_p.From(tmp_signed_char);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from signed_char, hd_prim_char_p.From(tmp_signed_char) converted incorrectly from " << tmp_signed_char << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from signed_char, hd_prim_char_p.From(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_short = 1;
    try {
      hd_prim_char_p.From(tmp_short);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from short, hd_prim_char_p.From(tmp_short) converted incorrectly from " << tmp_short << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from short, hd_prim_char_p.From(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_int = 1;
    try {
      hd_prim_char_p.From(tmp_int);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from int, hd_prim_char_p.From(tmp_int) converted incorrectly from " << tmp_int << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from int, hd_prim_char_p.From(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long = 1;
    try {
      hd_prim_char_p.From(tmp_long);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from long, hd_prim_char_p.From(tmp_long) converted incorrectly from " << tmp_long << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from long, hd_prim_char_p.From(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_char = 1;
    try {
      hd_prim_char_p.From(tmp_unsigned_char);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_char, hd_prim_char_p.From(tmp_unsigned_char) converted incorrectly from " << tmp_unsigned_char << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_char, hd_prim_char_p.From(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_short = 1;
    try {
      hd_prim_char_p.From(tmp_unsigned_short);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_short, hd_prim_char_p.From(tmp_unsigned_short) converted incorrectly from " << tmp_unsigned_short << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_short, hd_prim_char_p.From(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_int = 1;
    try {
      hd_prim_char_p.From(tmp_unsigned_int);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_int, hd_prim_char_p.From(tmp_unsigned_int) converted incorrectly from " << tmp_unsigned_int << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_int, hd_prim_char_p.From(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_long = 1;
    try {
      hd_prim_char_p.From(tmp_unsigned_long);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_long, hd_prim_char_p.From(tmp_unsigned_long) converted incorrectly from " << tmp_unsigned_long << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_long, hd_prim_char_p.From(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_float = 1;
    try {
      hd_prim_char_p.From(tmp_float);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from float, hd_prim_char_p.From(tmp_float) converted incorrectly from " << tmp_float << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from float, hd_prim_char_p.From(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_double = 1;
    try {
      hd_prim_char_p.From(tmp_double);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from double, hd_prim_char_p.From(tmp_double) converted incorrectly from " << tmp_double << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from double, hd_prim_char_p.From(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long_double = 1;
    try {
      hd_prim_char_p.From(tmp_long_double);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from long_double, hd_prim_char_p.From(tmp_long_double) converted incorrectly from " << tmp_long_double << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from long_double, hd_prim_char_p.From(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_signed_char = 0;
    try {
      hd_prim_char_p.To(tmp_signed_char);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from signed_char, hd_prim_char_p.To(tmp_signed_char) converted incorrectly from " << tmp_signed_char << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from signed_char, hd_prim_char_p.To(tmp_signed_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_short = 0;
    try {
      hd_prim_char_p.To(tmp_short);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from short, hd_prim_char_p.To(tmp_short) converted incorrectly from " << tmp_short << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from short, hd_prim_char_p.To(tmp_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_int = 0;
    try {
      hd_prim_char_p.To(tmp_int);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from int, hd_prim_char_p.To(tmp_int) converted incorrectly from " << tmp_int << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from int, hd_prim_char_p.To(tmp_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long = 0;
    try {
      hd_prim_char_p.To(tmp_long);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from long, hd_prim_char_p.To(tmp_long) converted incorrectly from " << tmp_long << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from long, hd_prim_char_p.To(tmp_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_char = 0;
    try {
      hd_prim_char_p.To(tmp_unsigned_char);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_char, hd_prim_char_p.To(tmp_unsigned_char) converted incorrectly from " << tmp_unsigned_char << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_char, hd_prim_char_p.To(tmp_unsigned_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_short = 0;
    try {
      hd_prim_char_p.To(tmp_unsigned_short);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_short, hd_prim_char_p.To(tmp_unsigned_short) converted incorrectly from " << tmp_unsigned_short << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_short, hd_prim_char_p.To(tmp_unsigned_short) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_int = 0;
    try {
      hd_prim_char_p.To(tmp_unsigned_int);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_int, hd_prim_char_p.To(tmp_unsigned_int) converted incorrectly from " << tmp_unsigned_int << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_int, hd_prim_char_p.To(tmp_unsigned_int) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_unsigned_long = 0;
    try {
      hd_prim_char_p.To(tmp_unsigned_long);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from unsigned_long, hd_prim_char_p.To(tmp_unsigned_long) converted incorrectly from " << tmp_unsigned_long << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from unsigned_long, hd_prim_char_p.To(tmp_unsigned_long) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_float = 0;
    try {
      hd_prim_char_p.To(tmp_float);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from float, hd_prim_char_p.To(tmp_float) converted incorrectly from " << tmp_float << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from float, hd_prim_char_p.To(tmp_float) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_double = 0;
    try {
      hd_prim_char_p.To(tmp_double);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from double, hd_prim_char_p.To(tmp_double) converted incorrectly from " << tmp_double << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from double, hd_prim_char_p.To(tmp_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_long_double = 0;
    try {
      hd_prim_char_p.To(tmp_long_double);
      if (strcmp(hd_prim_char_p.Data(), "1"))
        std::cerr << "ERROR: While converting from long_double, hd_prim_char_p.To(tmp_long_double) converted incorrectly from " << tmp_long_double << " to " << hd_prim_char_p.Data() << std::endl;
    } catch (const Hexception &x) {
      std::cerr << "ERROR: While converting from long_double, hd_prim_char_p.To(tmp_long_double) returned incorrect code " << code[x.Code()] << std::endl;
    }
    tmp_bool = false;
    try {
      hd_prim_char_p.To(tmp_bool);
    } catch (const Hexception &x) {
        std::cerr << "ERROR: While converting from bool, hd_prim_char_p.To(tmp_bool) returned incorrect code " << code[x.Code()] << std::endl;
    }
    if (true != tmp_bool)
      std::cerr << "ERROR: While converting from bool, hd_prim_char_p.To(tmp_bool) converted incorrectly from " << hd_prim_char_p.Data() << " to " << tmp_bool << std::endl;
    tmp_char = 0;
    try {
      hd_prim_char_p.To(tmp_char);
      std::cerr << "ERROR: While converting from char, hd_prim_char_p.To(tmp_char) didn't throw" << std::endl;
    } catch (const Hexception &x) {
      if (P_SIGNEDNESS != x.Code())
        std::cerr << "ERROR: While converting from char, hd_prim_char_p.To(tmp_char) returned incorrect code " << code[x.Code()] << std::endl;
    }
    if (1 != tmp_char)
      std::cerr << "ERROR: While converting from char, hd_prim_char_p.To(tmp_char) converted incorrectly from " << hd_prim_char_p.Data() << " to " << tmp_char << std::endl;

  } catch (const Hexception &x) {
    std::cerr << "An unexpected exception " << code[status] << " was caught at the top level!" << std::endl;
    SetGlobalStatus(status);
  } catch (...) {
    std::cerr << "A completely unexpected exception was caught at the top level!" << std::endl;
    SetGlobalStatus(-1);
  }

  // Final status check and report.
  if (P_OK == sStatus)
    std::cout << "Test succeeded." << std::endl;
  else
    std::cerr << "Test failed with error " << code[sStatus] << std::endl;
  return sStatus;
}
